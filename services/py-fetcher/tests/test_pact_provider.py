"""
Pact provider test for py-fetcher service.

This test verifies that py-fetcher can satisfy the contracts 
defined by the api-server consumer test.
"""

import pytest
import subprocess
import time
import requests
import os
from pact import Verifier
import datetime
from niche_explorer_models.models.article import Article


class TestPyFetcherProvider:
    """
    Provider test that verifies py-fetcher satisfies the contract
    from api-server consumer test.
    """

    @pytest.fixture(scope="module")
    def provider_service(self):
        """Start py-fetcher service for testing"""
        # Start the FastAPI service
        process = subprocess.Popen([
            "python3", "-m", "uvicorn", 
            "src.main:app", 
            "--host", "127.0.0.1", 
            "--port", "8200"
        ])
        
        # Wait for service to start
        self._wait_for_service("http://127.0.0.1:8200/health")
        
        yield "http://127.0.0.1:8200"
        
        # Cleanup
        process.terminate()
        process.wait()

    def _wait_for_service(self, url, timeout=30):
        """Wait for service to be ready"""
        start_time = time.time()
        while time.time() - start_time < timeout:
            try:
                response = requests.get(url)
                if response.status_code == 200:
                    return
            except requests.exceptions.ConnectionError:
                pass
            time.sleep(1)
        raise Exception(f"Service at {url} did not start within {timeout} seconds")

    def test_against_api_server_contract(self, provider_service, mocker):
        """
        Verify py-fetcher can satisfy the contract from api-server.
        
        This loads the pact file generated by the consumer test and
        replays all the requests against the real py-fetcher service.
        """
        # Path to pact file (generated by consumer test)
        pact_file = os.path.join(
            os.path.dirname(__file__),
            "../../spring-api/build/pacts/api-server-py-fetcher.json"
        )
        
        # Ensure pact file exists
        if not os.path.exists(pact_file):
            pytest.fail(f"Pact file not found at {os.path.abspath(pact_file)}. "
                       "Please run the consumer test first to generate the contract.")
        
        verifier = Verifier(
            provider="py-fetcher",
            provider_base_url=provider_service
        )

        # Provider states - these correspond to the "given" clauses in consumer test
        def arxiv_service_available():
            """Set up state: arxiv service is available for fetching articles."""
            # This state is for the 'POST /api/v1/articles' interaction.
            # We mock the external dependency (arxiv_fetcher) to ensure
            # we are testing the service's logic in isolation.
            mock_article = Article(
                id="2301.00001",
                title="Advanced Machine Learning Techniques",
                link="https://arxiv.org/abs/2301.00001",
                summary="This paper explores advanced ML techniques...",
                authors=["John Doe", "Jane Smith"],
                published=datetime.datetime(2023, 1, 1, 12, 0, 0, tzinfo=datetime.timezone.utc),
                source="arxiv"
            )

            async def mock_fetch(*args, **kwargs):
                return [mock_article]

            # Patch the fetch method of the arxiv_fetcher singleton
            mocker.patch(
                "src.services.arxiv_service.arxiv_fetcher.fetch",
                side_effect=mock_fetch
            )
            return True

        def arxiv_categories_are_available():
            """Set up state: arxiv categories are available."""
            # This state is for the 'GET /api/v1/sources/{source}/categories' interaction.
            # The logic for this endpoint is hardcoded in the py-fetcher service,
            # so no specific setup is required. The test will hit the real endpoint code.
            return True

        # Configure provider states
        provider_states = {
            "arxiv service is available": arxiv_service_available,
            "arxiv categories are available": arxiv_categories_are_available,
        }

        # Run verification
        success, logs = verifier.verify_pacts(
            pact_file,
            provider_states=provider_states,
            verbose=True,
            enable_pending=False
        )

        assert success, f"Provider verification failed: {logs}" 